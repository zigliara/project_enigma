# Project Enigma - Python 2.7.10# Emulate the Enigma Machineimport sys"""Based on info from:1. http://www.matematiksider.dk/enigma_eng.html2. https://en.wikipedia.org/wiki/Enigma_rotor_detailsConstraints:Emulates the Enigma M4 (1942) (Rotors I, II and III and Reflector B-wide)according to link 2Handles 26 capital letters.Wheel N will rotate 1/26 each time a new character is entered.Implementation of double-stepping will not be implemented at first.The plugboard will be simulated but not used.Spaces will be removed from the input strings.""""""Configuration:Wheel R (Rotor I) configuration:EKMFLGDQVZNTOWYHXUSPAIBRCJTurn-over notch position: 'Q'Wheel M (Rotor II) configuration:AJDKSIRUXBLHWTMCQGZNPYFVOETurn-over notch position: 'E'Wheel L (Rotor III) configuration:BDFHJLCPRTXVZNYEIWGAKMUSQOTurn-over notch position: 'V'Reflector B-wide configuration:YRUHQSLDPXNGOKMIEBFZCWVJAT"""class Rotor(object):    my_rotor = []    def __init__(self, my_wheel):        self.my_wheel = my_wheel         alphabet = [chr(i) for i in range(65, 91)]        if my_wheel == 3:            rotor_config = ['E', 'K', 'M', 'F', 'L', 'G', 'D', 'Q', 'V', 'Z', 'N', 'T', 'O', 'W', 'Y', 'H', 'X', 'U', 'S', 'P', 'A', 'I', 'B', 'R', 'C', 'J']            self.my_notch = 'Q'        elif my_wheel == 2:            rotor_config = ['A', 'J', 'D', 'K', 'S', 'I', 'R', 'U', 'X', 'B', 'L', 'H', 'W', 'T', 'M', 'C', 'Q', 'G', 'Z', 'N', 'P', 'Y', 'F', 'V', 'O', 'E']            self.my_notch = 'E'        elif my_wheel == 1:            rotor_config = ['B', 'D', 'F', 'H', 'J', 'L', 'C', 'P', 'R', 'T', 'X', 'V', 'Z', 'N', 'Y', 'E', 'I', 'W', 'G', 'A', 'K', 'M', 'U', 'S', 'Q', 'O']            self.my_notch = 'V'        else:            rotor_config = ['Y', 'R', 'U', 'H', 'Q', 'S', 'L', 'D', 'P', 'X', 'N', 'G', 'O', 'K', 'M', 'I', 'E', 'B', 'F', 'Z', 'C', 'W', 'V', 'J', 'A', 'T']            self.my_notch = ''                self.my_rotor = zip(alphabet, rotor_config)# Get rotor offset configuration from the userdef get_start_index():    pos_one = 0    pos_two = 0    pos_three = 0    alphabet = [chr(i) for i in range(65, 91)]    while True:        wheel_r = raw_input('Which letter shall the R-wheel be set to? ')        if wheel_r.upper() in alphabet:            pos_one = alphabet.index(wheel_r.upper())        wheel_m = raw_input('Which letter shall the M-wheel be set to? ')        if wheel_m.upper() in alphabet:            pos_two = alphabet.index(wheel_m.upper())        wheel_l = raw_input('Which letter shall the L-wheel be set to? ')        if wheel_l.upper() in alphabet:            pos_three = alphabet.index(wheel_l.upper())            print pos_three, 'pos_three'        return pos_one, pos_two, pos_three# Get ring setting configuration from the user for the chosen ringsdef get_ring_setting_index():    ring_setting_one = 0    ring_setting_two = 0    ring_setting_three = 0    alphabet = [chr(i) for i in range(65, 91)]    while True:        wheel_n = raw_input('Which ring setting shall the N-wheel be set to? ')        if wheel_n.upper() in alphabet:            ring_setting_one = alphabet.index(wheel_n.upper())        wheel_m = raw_input('Which ring setting shall the M-wheel be set to? ')        if wheel_m.upper() in alphabet:            ring_setting_two = alphabet.index(wheel_m.upper())        wheel_l = raw_input('Which ring setting shall the L-wheel be set to? ')        if wheel_l.upper() in alphabet:            ring_setting_three = alphabet.index(wheel_l.upper())        wheel_k = raw_input('Which ring setting shall the K-wheel be set to? ')        return ring_setting_one, ring_setting_two, ring_setting_three# Introductiondef intro_enigma():    print 'Welcome to the Enigma emulator!'    print 'You will be asked to enter the Enigma-configuration, as well as the text you want encrypted'    while True:        answer = raw_input('Do you wish to continue or terminate the application? [continue/abort] ')        if answer.lower() == 'continue' or answer.lower() == 'c':            return True        elif answer.lower() == 'abort' or answer.lower() == 'a':            print 'Auf wiedersehen.'            sys.exit(1)        else:            print 'Please answer with \'continue\' or \'abort\'.'# Set the rotors to their start position# Based on the index settingdef set_to_start(start_index, rotor):    temp_rotor = Rotor(my_wheel = 1)    for i in range(len(rotor.my_rotor)):        if i + start_index < len(rotor.my_rotor):            temp_rotor.my_rotor[i] = rotor.my_rotor[i+start_index]        else:            temp_rotor.my_rotor[i] = rotor.my_rotor[(i+start_index) % len(rotor.my_rotor)]    rotor.my_rotor = temp_rotor.my_rotor    return rotor# Read the message to encryptdef read_message(rotor1, start_index_one, rotor2, start_index_two, rotor3, start_index_three, rotor4):    message = raw_input('Type in the message you want encrypted: ')    message = message.upper().strip().replace(' ', '')    encrypted_message = ''    print message    #Check if the characters are only A to Z, answer again otherwise    for index in range(len(message)):                # Call the encryption function        encrypted_message += get_encrypted_char(message[index], index, rotor1, rotor2, rotor3, rotor4, start_index_one, start_index_two, start_index_three)        # Print string of 5 characters, separated by a space    parsed_message = ''    for i in range(len(encrypted_message)):        if not i % 4 == 0:            parsed_message += encrypted_message[i]        if i % 4 == 0:            parsed_message += ' ' + encrypted_message[i]    print parsed_message.strip()    print encrypted_message    # Get the encrypted characterdef get_encrypted_char(letter, index, rotor1, rotor2, rotor3, reflector, start_index_one, start_index_two, start_index_three):    # 1st step: Let the 1st rotor rotate one more step than the index of the letter to be encrypted    offset = index + 1        # Check for wrap-around in case the new_index would not be one of the defined letters, ie between ACSCII 65 and 90    new_index = ord(letter) + offset    print new_index, 'new_index1'    while new_index > 90 or new_index < 65:        if new_index > 90:            new_index = new_index - 91 + 65        elif new_index < 65:            new_index = new_index - 65 + 91    rotor1_in = rotor1.my_rotor[new_index-65][0]    print rotor1_in, 'rotor1_in'    rotor1_out = rotor1.my_rotor[new_index-65][1]    print rotor1_out, 'rotor1_out'    # 2nd step: Back the offset with the index for the middle rotor    new_index = ord(rotor1_out) - offset - start_index_one + start_index_two    while new_index > 90 or new_index < 65:        if new_index > 90:            new_index = new_index - 91 + 65        elif new_index < 65:            new_index = new_index - 65 + 91    rotor2_in = chr(new_index)    print rotor2_in, 'rotor2_in'    for i in range(len(rotor2.my_rotor)):        if rotor2_in in rotor2.my_rotor[i]:            if rotor2.my_rotor[i][0] == rotor2_in:                rotor2_out = rotor2.my_rotor[i][1]                break    print rotor2_out, 'rotor2_out'        # 3rd step: Get the output for the 3rd, left, wheel    new_index = ord(rotor2_out) - start_index_two + start_index_three    while new_index > 90 or new_index < 65:        if new_index > 90:            new_index = new_index - 91 + 65        elif new_index < 65:            new_index = new_index - 65 + 91    rotor3_in = chr(new_index)    print rotor3_in, 'rotor3_in'    for i in range(len(rotor3.my_rotor)):        if rotor3_in in rotor3.my_rotor[i]:            if rotor3.my_rotor[i][0] == rotor3_in:                rotor3_out = rotor3.my_rotor[i][1]                break    print rotor3_out, 'rotor3_out'        # Step 4: Return the output from the Reflector    #reflector_in = rotor3_out    new_index = ord(rotor3_out) - start_index_three    while new_index > 90 or new_index < 65:        if new_index > 90:            new_index = new_index - 91 + 65        elif new_index < 65:            new_index = new_index - 65 + 91    reflector_in = chr(new_index)    print reflector_in, 'reflector_in'    for i in range(len(reflector.my_rotor)):        if reflector_in in reflector.my_rotor[i]:            if reflector.my_rotor[i][0] == reflector_in:                reflector_out = reflector.my_rotor[i][1]                break    print reflector_out, 'reflector_out'        # Step 5: Go back, use the other side of the tuple    #rotor3_in = reflector_out    new_index = ord(reflector_out) + start_index_three    while new_index > 90 or new_index < 65:        if new_index > 90:            new_index = new_index - 91 + 65        elif new_index < 65:            new_index = new_index - 65 + 91    rotor3_in = chr(new_index)    print rotor3_in, 'rotor3_in'    for i in range(len(rotor3.my_rotor)):        if rotor3_in in rotor3.my_rotor[i]:            if rotor3.my_rotor[i][1] == rotor3_in:                rotor3_out = rotor3.my_rotor[i][0]                break    print rotor3_out, 'rotor3_out'        # Step 6: Go through the middle rotor    new_index = ord(rotor3_out) - start_index_three + start_index_two    while new_index > 90 or new_index < 65:        if new_index > 90:            new_index = new_index - 91 + 65        elif new_index < 65:            new_index = new_index - 65 + 91    rotor2_in = chr(new_index)    print rotor2_in, 'rotor2_in'    for i in range(len(rotor2.my_rotor)):        if rotor2_in in rotor2.my_rotor[i]:            if rotor2.my_rotor[i][1] == rotor2_in:                rotor2_out = rotor2.my_rotor[i][0]                break    print rotor2_out, 'rotor2_out'        # Step 7: Get back the offset, see step 2 reversed    new_index = ord(rotor2_out) + offset + start_index_one - start_index_two    while new_index > 90 or new_index < 65:        if new_index > 90:            new_index = new_index - 91 + 65        elif new_index < 65:            new_index = new_index - 65 + 91    rotor1_in = chr(new_index)    print rotor1_in, 'rotor1_in'    for i in range(len(rotor1.my_rotor)):        if rotor1_in in rotor1.my_rotor[i]:            if rotor1.my_rotor[i][1] == rotor1_in:                rotor1_out = rotor1.my_rotor[i][0]                break    print rotor1_out, 'rotor1_out'        # Step 8: Reverse step 1 to get the final letter    new_index = ord(rotor1_out) - offset - start_index_one    #new_index = ord(rotor1_out) - letter_index    print new_index, 'new_index'    while new_index > 90 or new_index < 65:        if new_index > 90:            new_index = new_index - 91 + 65        elif new_index < 65:            new_index = new_index - 65 + 91    letter = chr(new_index)    print letter, 'letter'    return letter# Main functiondef main():    if intro_enigma(): # If the user wants to proceed        # Get the ring settings (internal wiring) from the user        ring_setting_one, ring_setting_two, ring_setting_three = get_ring_setting_index()        # Create the wheels        rotor1 = Rotor(my_wheel = 1)        rotor2 = Rotor(my_wheel = 2)        rotor3 = Rotor(my_wheel = 3)        reflector = Rotor(my_wheel = 5)                # Get the start configuration (ring start index) from the user        start_index_one, start_index_two, start_index_three = get_start_index()                # Set the wheels to their start position        rotor1 = set_to_start(start_index_one, rotor1)        rotor2 = set_to_start(start_index_two, rotor2)        rotor3 = set_to_start(start_index_three, rotor3)        print 'rotor1', rotor1.my_rotor        print 'rotor2', rotor2.my_rotor        print 'rotor3', rotor3.my_rotor        # Read in the message        read_message(rotor1, start_index_one, rotor2, start_index_two, rotor3, start_index_three, reflector)# Init functionif __name__ == '__main__':    main()"""Additional rotors available to the M4:Rotor IV configuration:ESOVPZJAYQUIRHXLNFTGKDCMWBTurn-over notch position: 'J'Rotor V configuration:VZBRGITYUPSDNHLXAWMJQOFECKTurn-over notch position: 'Z'Rotor VI configuration:JPGVOUMFYQBENHZRDKASXLICTWTurn-over notch positions: 'Z' and 'M'Rotor VII configuration:NZJHGRCXMYSWBOUFAIVLPEKQDTTurn-over notch positions: 'Z' and 'M'Rotor VIII configuration:FKQHTLXOCBJSPDZRAMEWNIUYGVTurn-over notch positions: 'Z' and 'M'Rotor Gamma configuration:FSOKANUERHMBTIYCWLQPZXVGJDAdditional reflector available to the M4:Reflector C-thin:RDOBJNTKVEHMLFCWZAXGYIPSUQ"""